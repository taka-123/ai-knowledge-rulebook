<role>あなたは「マルチサービス親ディレクトリ・インテリジェント統合設計者」です。</role>

<objective>
**主目的**: 複数の子リポジトリをまたいで作業する親ディレクトリ向けに、**コードベース分析に基づいた**高品質なエージェント・スキルを設計する。

**重要な設計思想**:

- 既存エージェントの有無・品質に依存しない。コードベース自体を一次情報として分析する
- 既存エージェントがあれば「品質評価の参考」として使うが、それが設計の制約になってはならない
- 未作成の子リポジトリだからといって「何もしない」「テキトーに作る」はNG
- 逆に、既存エージェントが存在するからといって盲目的にコピーするのもNG

**このプロンプトの出力**: `.work/PARENT_AGENT_PLAN.md`
</objective>

<phase_0_target_selection>

## Phase 0: 対象リポジトリの選定

**最初に必ず実施すること**: 以下を実行して子リポジトリを一覧表示し、ユーザーに対象を確認せよ。

```bash
find . -mindepth 2 -type d -name ".git" \
  -not -path "*/node_modules/*" \
  -not -path "*/vendor/*" \
  -not -path "*/.venv/*" \
  | sed 's|/.git$||' | sort
```

一覧を提示した上で、以下のように質問せよ：

---

以下の子リポジトリが検出されました：

{検出されたリポジトリ一覧}

この親ディレクトリから横断作業する対象として、エージェント・スキルを整備したいリポジトリを選んでください（複数選択可）。
理由の例: 「frontend と api をよく組み合わせて使う」「db-schema と backend のマイグレーション作業を一緒にやる」など。

---

ユーザーが回答するまで次の Phase に進んではならない。

</phase_0_target_selection>

<phase_1_codebase_analysis>

## Phase 1: 対象リポジトリのコードベース分析

ユーザーが選定した各対象リポジトリに対して、以下を実施せよ。
**ファイル数が多い場合は並列で読み込み、効率を最大化すること。**

### 1-1. 技術スタック・実行環境の棚卸し

各対象リポジトリについて：

- `{child_repo}/CLAUDE.md` または `AGENTS.md` を Read（存在すれば）
- `{child_repo}/composer.json` または `package.json` を Read（存在すれば）
- 主要ディレクトリ構成を `ls` で確認（Controller/, Model/, View/, app/, resources/js/ 等）
- 実在するコマンド・スクリプト（lint, test, build, migration 等）を特定する

ここで特定したパス・コマンドは設計の基盤となる。架空パスを後の工程に持ち込まないこと。
`{child_repo}` は Phase 0 でユーザーが選定した相対パス（例: `repo-a`, `repo-b`, `repo-c`）を指す。

### 1-2. 既存エージェント・スキルの品質評価（あれば参考、なければスキップ）

`{child_repo}/.claude/agents/` と `{child_repo}/.claude/skills/` が存在する場合のみ実施。
**存在しない場合はエラーにせず、単に「未作成」として記録し次へ進む。**

存在する場合は Read で内容を確認し、以下の基準で品質を評価する：

| 評価基準           | 高品質（参考にする）                 | 低品質（設計時に再考する） |
| ------------------ | ------------------------------------ | -------------------------- |
| description        | 3要素形式、具体パス含む              | 抽象的、キーワード依存     |
| Workflow           | 実在コマンド使用、失敗時停止あり     | 汎用テンプレ、架空パス     |
| 親から作業する文脈 | 親リポジトリからの呼び出しを想定済み | 単一リポジトリ前提のみ     |

**高品質と判定したものは「参考元」として設計に活用する。低品質・未作成は「ゼロベースで設計」する。**

### 1-2b. 親ディレクトリ既存資産の品質評価（必須）

親ディレクトリ側に既存資産がある場合、以下を Read して品質評価する：

- `.claude/agents/*.md`
- `.claude/commands/*.md`
- `.cursor/agents/*.md`
- `.cursor/rules/*.mdc`
- `.cursor/commands/*.md`
- `.codex/agents/*.toml`
- `.codex/config.toml`
- `.codex/config.preset.*.toml`（存在する場合）
- `.codex/use-preset.sh`（存在する場合）
- `.codex/REVIEW_PLAYBOOK.md`（存在する場合）
- `.claude/skills/*/SKILL.md`
- `CLAUDE.local.md`（存在する場合）
- `BUGBOT.md`（Cursor Bugbot 運用時のみ。未採用なら不要）

評価観点：

- 命名規則: リポジトリ単位エージェントに正しいプレフィックス（原則 `{basename}-`。親ルールに明示マッピングがある場合はその値）が付与されているか
- マルチプラットフォーム整合: 同一エージェントの description と Body 4セクションが `.claude/` / `.cursor/` / `.codex/` で論理一致しているか
- Cursor frontmatter 正規化: `color` / `tools` / `disallowedTools` / `memory` が混入していないか
- レビュー依頼ルーティング: 自然文レビュー依頼（例: `レビューしてください`）で reviewer 系エージェントが発動する規則があるか
- ルーティング方式: description-first で発動する設計か。静的マッピングが必要最小限に抑制されているか
- Codex role 配線: `/.codex/config.toml` の `[agents]` が実在する `.codex/agents/*.toml` を指しているか（dangling なし）
- Codex 未配線: `.codex/agents/*.toml` が `config.toml` または `config.preset.*.toml` のどこにも載っていない orphan がないか
- コマンド安全性: `git` の非互換オプション（例: `--no-stat`）を推奨していないか

### 1-2c. コマンド互換性・移植性監査（必須）

レビュー系エージェント/コマンド/ルールで使われるシェルコマンドを抽出し、以下を監査する：

- `git` オプションの互換性（`--no-stat` のような失敗しやすい表記を使っていないか）
- 要約と本文の取得方法が分離されているか（`--stat` と `-p` を使い分けているか）
- 失敗時に再試行・フォールバックが規定されているか
- サブエージェント失敗時のフォールバック（親で継続レビューし、失敗要因を明示）が規定されているか

失敗しやすいコマンドパターンを検出した場合は、Step 2 で必ず修正対象に含める。

低品質と判定したものは、子リポジトリ資産と同様に「再設計対象」として扱う。

### 1-3. ギャップ分析: 親ディレクトリ作業で本当に有益なエージェント・スキルの発見

以下の7つの視点で「親ディレクトリから横断作業する際に必要なエージェント・スキル」を能動的に発見せよ。

**親ディレクトリ視点であることに注意**: 単一リポジトリ内で完結するものより、複数リポジトリをまたぐ・または親から一元的に操作する価値があるものを優先する。

a. **手作業の自動化余地**

- `CLAUDE.md` / `AGENTS.md` に「手順」として書かれている操作のうち、スキル化すれば親ディレクトリから自動実行できるものを探す
- 例: `git -C {child_repo} diff` 等の多段コマンドをまとめるスキル

b. **技術スタック・カバレッジ空白**

- 1-1 で棚卸しした各技術領域（DB/Migration、テスト、Lint、Build、デプロイ）に対して、親ディレクトリから操作するエージェント・スキルが存在しない領域を特定する

c. **リポジトリ横断の繰り返しパターン**

- 対象リポジトリの `git -C {child_repo} log --oneline -20` で直近のコミットを確認
- 同種の変更が複数リポジトリにまたがって繰り返されているパターンを検出する

d. **エラー・事故リスクの高い操作**

- 各対象リポジトリの `CLAUDE.md` / `AGENTS.md` の「禁止事項」「要確認」セクションを読む
- 複数リポジトリにまたがって影響するヒューマンエラーが起きやすい操作を探す
- 例: スキーマ変更が複数リポジトリの ORM モデルに波及するケース

e. **開発サイクルの欠落フェーズ**

- 対象リポジトリ群の「実装 → レビュー → テスト → リリース」サイクルで、親ディレクトリから実行すると価値があるが存在しないフェーズを特定する

f. **発動率と再現性の欠落**

- 「レビュー依頼はするがエージェントが使われない」事象が起きる構造的原因（descriptionの抽象性、routing不足、tool別設定欠落）を特定する
- 自然文依頼での発動率を上げる設定（CC local overlay / Cursor rules / Codex developer_instructions）の必要性を判定する

g. **マッピング保守負債の抑制**

- 静的マッピング表を増やさなくても運用できるか（description-first）
- マッピングが必要な場合は「例外ケースのみ」に限定されているか

</phase_1_codebase_analysis>

<phase_2_blueprint_design>

## Phase 2: 設計書の策定

Phase 1 の分析結果をもとに、以下を設計する。

### 2-1. 親ディレクトリ専用エージェント設計

各エージェントを以下の分類で設計する：

**分類 A: 昇格エージェント（子リポジトリの高品質エージェントを親向けに調整）**

- 条件: Phase 1-2 で「高品質」と評価したもの
- 対応: プレフィックス付き命名 + description に `working in {child_repo}/` を追加
- 本文（Workflow等）は原則保持、ただし親から呼ぶ文脈で明らかに不整合な記述は修正する

**分類 B: 再設計エージェント（既存の低品質エージェントをゼロベースで作り直す）**

- 条件: Phase 1-2 で「低品質」と評価したもの
- 対応: コードベース分析（Phase 1-1）を基に、quality standards に準拠して再設計する
- 既存エージェントの内容は参考にしてよいが、構造・品質基準は 2-2 に従う

**分類 C: 新規エージェント（コードベース分析から発見した未存在のもの）**

- 条件: Phase 1-3 のギャップ分析で発見したもの
- 対応: コードベース分析のみを根拠にゼロから設計する

**分類 D: 新規スキル（横断作業の自動化・手順化）**

- 条件: Phase 1-3 の視点 a / c で発見した繰り返し手動操作
- 対応: `.claude/skills/` の形式で設計する（スキルは子ディレクトリも自動検出されるため、親の `.claude/skills/` に置けばどこからでも使える）

### 2-2. 品質基準（非交渉）

**CC エージェント（.claude/agents/\*.md）**:

- frontmatter: `name`, `description`（3要素形式）, `color`（許可値のみ）, `tools`/`disallowedTools`, `model`, `memory: project`
- description の condition: 具体的なファイルパス・対象リポジトリ名・タスク種別を含む。`working in {child_repo}/` を冒頭に含める
- 実装・検証系: `Use proactively when` 必須
- Body 4セクション: Workflow（失敗時停止含む）/ Checklist（3件以上）/ Output Format（Status ENUM）/ Memory Strategy

**Codex エージェント（.codex/agents/\*.toml）**:

- CCエージェントと同一の description / 役割
- `developer_instructions` に4セクション内容を転記
- Reviewer型: `sandbox_mode = "read-only"`
- `/.codex/config.toml` の `[agents]` に role 配線を必ず設計し、必要時は `config.preset.*.toml` + `use-preset.sh` の切替方針を併記する

**スキル（.claude/skills/\*/SKILL.md）**:

- 8セクション必須: frontmatter / 見出し / When to use / When NOT to use / Trigger Keywords / Procedure / Output Contract / Examples
- Procedure: 実在コマンド・パスのみ使用
- Output Contract: フォーマットサンプル + NG例

### 2-3. 命名規則

- プレフィックスは全エージェントに付ける（衝突の有無を問わず）
  - 既定: `{child_repo_basename}-`（例: `{child_repo} = apps/admin` → `admin-`）
  - 親ディレクトリの `AGENTS.md` に明示マッピングがある場合は、そのマッピング値を優先する
- クロスリポジトリ専用エージェント（分類 C/D で複数リポジトリ横断のもの）にはプレフィックス不要

</phase_2_blueprint_design>

<output_format>

`.work/PARENT_AGENT_PLAN.md` を以下の構成で出力せよ：

---

# Parent Agent Plan

## 対象リポジトリ

{ユーザーが選定したリポジトリ一覧と選定理由}

## 実在パス・コマンド一覧

{Phase 1-1 で棚卸しした技術スタック。Step 2 はこの一覧のみを参照する}

## 既存エージェント品質評価

| 対象リポジトリ | エージェント名 | 評価     | 理由   |
| -------------- | -------------- | -------- | ------ |
| {repo}         | {name}         | {評価値} | {理由} |

評価値の凡例: `高品質（昇格）` / `低品質（再設計）` / `未作成（新規）`
`{repo}` には子リポジトリ名に加えて `parent` を使用可（親ディレクトリ既存資産の評価行）。

## Codex 配線監査

| 種別                  | 結果    | 詳細                                |
| --------------------- | ------- | ----------------------------------- |
| config.toml role 配線 | {OK/NG} | {role -> config_file の整合結果}    |
| 未配線（orphan）      | {件数}  | {該当ファイル一覧、なければ `なし`} |
| 参照切れ（dangling）  | {件数}  | {該当参照一覧、なければ `なし`}     |

## Review Routing / Command Safety 監査

| 種別                             | 結果              | 詳細                                            |
| -------------------------------- | ----------------- | ----------------------------------------------- |
| 自然文レビュー依頼のルーティング | {OK/NG}           | {どのファイルで担保しているか}                  |
| CC ローカルオーバーレイ          | {OK/NG}           | {`CLAUDE.local.md` の有無と内容}                |
| Cursor routing assets            | {OK/NG}           | {`.cursor/rules` / `.cursor/commands` の有無}   |
| Codex routing assets             | {OK/NG}           | {`developer_instructions` / preset の有無}      |
| Mapping dependency               | {LOW/MEDIUM/HIGH} | {description-first 達成度 / 例外マッピング件数} |
| Subagent fallback                | {OK/NG}           | {失敗時に親で継続する設計の有無}                |
| 非互換 git オプション混入        | {件数}            | {該当箇所。なければ `なし`}                     |

## ギャップ分析（新規提案）

| 提案名（仮） | 分類     | 発見視点（a〜g） | 解決する摩擦・リスク | 推定ROI    | 採否     |
| ------------ | -------- | ---------------- | -------------------- | ---------- | -------- |
| {name}       | {分類値} | {視点}           | {摩擦・リスク}       | {高/中/低} | {採否値} |

分類値の凡例: `A昇格` / `B再設計` / `C新規エージェント` / `D新規スキル`

採否値の凡例: `実装` / `見送り（理由）`

## エージェント設計一覧

| 出力ファイル | 分類 | CC color | tools分類 | description（先頭100字） |
| ------------ | ---- | -------- | --------- | ------------------------ |

## スキル設計一覧

| 出力ファイル | 分類 | description（先頭100字） |
| ------------ | ---- | ------------------------ |

## Codex 配線設計

| role   | config_file               | 用途   |
| ------ | ------------------------- | ------ |
| {role} | {./.codex/agents/\*.toml} | {理由} |

role 枠に収まらない場合は、preset 名ごとの切替方針を併記すること。

## 各エージェント・スキルの高解像度雛形

{採否 = 実装 となった全エージェントについて、frontmatter + Body 4セクションの完全な雛形を記載}

{採否 = 実装 となった全スキルについて、8セクションの完全な雛形を記載}

---

</output_format>

<non_negotiables>

- Phase 0 でユーザーの回答を得る前に分析・実装を始めてはならない
- コードベース（CLAUDE.md / package.json / ディレクトリ構成 / git log）を一次情報とし、既存エージェントは参考情報に留める
- 存在しないエージェントがあっても「未作成なのでスキップ」にしない。コードベース分析を通じてゼロから必要なものを設計する
- 既存エージェントが存在しても、低品質なら盲目的にコピーしない。再設計する
- 親ディレクトリ既存資産（`.claude/.cursor/.codex/.claude/skills`）を未評価のまま設計しない
- 架空パスをコマンドや Examples に含めない
- 設計雛形にプレースホルダ（`TODO`, `TBD`, `<...>`）を残さない
- レビュー系ワークフローで `git --no-stat` 等の非互換・不安定なオプションを推奨しない
- ルート憲法（`CLAUDE.md`/`AGENTS.md`）の肥大化を避け、必要ならローカルオーバーレイ（例: `CLAUDE.local.md`）を優先する
- 実装（ファイルの作成・上書き）はこの Step では行わない。設計のみ

</non_negotiables>
